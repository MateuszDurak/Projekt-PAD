<html>
<head>
<title>analiza_i_czyszczenie.ipynb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
analiza_i_czyszczenie.ipynb</font>
</center></td></tr></table>
<pre><span class="s0">#%% md 
</span><span class="s1">### PAD S21415  
### Wstępna analiza danych i czyszczenie 
 
#### Importy 
 
</span><span class="s0">#%% 
# Praca z danymi</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">scipy</span>
<span class="s2">import </span><span class="s1">sklearn</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">stats </span><span class="s2">import </span><span class="s1">zscore</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">linear_model </span><span class="s2">import </span><span class="s1">LinearRegression</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">impute </span><span class="s2">import </span><span class="s1">KNNImputer</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">model_selection </span><span class="s2">import </span><span class="s1">train_test_split</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">ensemble </span><span class="s2">import </span><span class="s1">RandomForestRegressor</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">metrics </span><span class="s2">import </span><span class="s1">mean_squared_error</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">impute </span><span class="s2">import </span><span class="s1">SimpleImputer</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">metrics </span><span class="s2">import </span><span class="s1">mean_absolute_error</span><span class="s3">, </span><span class="s1">r2_score</span>



<span class="s0"># Wizualizacja</span>
<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">import </span><span class="s1">matplotlib</span><span class="s3">.</span><span class="s1">pyplot </span><span class="s2">as </span><span class="s1">plt</span>
<span class="s2">import </span><span class="s1">seaborn </span><span class="s2">as </span><span class="s1">sns</span>
<span class="s2">import </span><span class="s1">missingno </span><span class="s2">as </span><span class="s1">msno</span>


<span class="s0">#%% md 
</span><span class="s1">##### Konfiguracja wizualizacji 
Tak, żeby wykresy były bardziej czytelne 
</span><span class="s0">#%% 
</span><span class="s3">%</span><span class="s1">matplotlib inline</span>
<span class="s1">mpl</span><span class="s3">.</span><span class="s1">style</span><span class="s3">.</span><span class="s1">use</span><span class="s3">( </span><span class="s4">'ggplot' </span><span class="s3">)</span>
<span class="s1">plt</span><span class="s3">.</span><span class="s1">style</span><span class="s3">.</span><span class="s1">use</span><span class="s3">(</span><span class="s4">'fivethirtyeight'</span><span class="s3">)</span>
<span class="s1">sns</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">context</span><span class="s3">=</span><span class="s4">&quot;notebook&quot;</span><span class="s3">, </span><span class="s1">palette</span><span class="s3">=</span><span class="s4">&quot;dark&quot;</span><span class="s3">, </span><span class="s1">style </span><span class="s3">= </span><span class="s4">'whitegrid' </span><span class="s3">, </span><span class="s1">color_codes</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
<span class="s1">params </span><span class="s3">= {</span>
    <span class="s4">'axes.labelsize'</span><span class="s3">: </span><span class="s4">&quot;large&quot;</span><span class="s3">,</span>
    <span class="s4">'xtick.labelsize'</span><span class="s3">: </span><span class="s4">'x-large'</span><span class="s3">,</span>
    <span class="s4">'legend.fontsize'</span><span class="s3">: </span><span class="s5">20</span><span class="s3">,</span>
    <span class="s4">'figure.dpi'</span><span class="s3">: </span><span class="s5">150</span><span class="s3">,</span>
    <span class="s4">'figure.figsize'</span><span class="s3">: [</span><span class="s5">25</span><span class="s3">, </span><span class="s5">7</span><span class="s3">]</span>
<span class="s3">}</span>
<span class="s1">plt</span><span class="s3">.</span><span class="s1">rcParams</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">params</span><span class="s3">)</span>
<span class="s0">#%% md 
</span><span class="s1">### Funkcje  
</span><span class="s0">#%% 
# Funkcja do obliczania metryk</span>
<span class="s2">def </span><span class="s1">calculate_metrics</span><span class="s3">(</span><span class="s1">y_true</span><span class="s3">, </span><span class="s1">predictions</span><span class="s3">, </span><span class="s1">X</span><span class="s3">):</span>
    <span class="s1">rmse </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">mean_squared_error</span><span class="s3">(</span><span class="s1">y_true</span><span class="s3">, </span><span class="s1">predictions</span><span class="s3">))</span>
    <span class="s1">mae </span><span class="s3">= </span><span class="s1">mean_absolute_error</span><span class="s3">(</span><span class="s1">y_true</span><span class="s3">, </span><span class="s1">predictions</span><span class="s3">)</span>
    <span class="s1">r2 </span><span class="s3">= </span><span class="s1">r2_score</span><span class="s3">(</span><span class="s1">y_true</span><span class="s3">, </span><span class="s1">predictions</span><span class="s3">)</span>
    <span class="s1">adjusted_r2 </span><span class="s3">= </span><span class="s5">1 </span><span class="s3">- (</span><span class="s5">1 </span><span class="s3">- </span><span class="s1">r2</span><span class="s3">) * (</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y_true</span><span class="s3">) - </span><span class="s5">1</span><span class="s3">) / (</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y_true</span><span class="s3">) - </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] - </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">rmse</span><span class="s3">, </span><span class="s1">mae</span><span class="s3">, </span><span class="s1">r2</span><span class="s3">, </span><span class="s1">adjusted_r2</span>

<span class="s0">#%% md 
</span><span class="s1">#### Załadowanie danych do data frame'a i ich wyświetlenie 
Zbadajmy pierwsze 100 rekordów 
</span><span class="s0">#%% 
</span><span class="s1">df </span><span class="s3">= </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">read_csv</span><span class="s3">(</span><span class="s4">'messy_data.csv'</span><span class="s3">)</span>
<span class="s1">print</span><span class="s3">(</span><span class="s4">f'Ilość rekordów: </span><span class="s2">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">df</span><span class="s3">. </span><span class="s1">index</span><span class="s3">)</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>
<span class="s1">df</span><span class="s3">.</span><span class="s1">head</span><span class="s3">(</span><span class="s5">100</span><span class="s3">)</span>

<span class="s0">#%% md 
</span><span class="s1">### Opis kolumn w kontekscie diamentów 
 
- **carat**:  
  Jednostka masy dla diamentów, równa 200 miligramom. Wpływa na wartość diamentu; im większy karat, tym wyższa wartość. 
 
- **x dimension**:  
  Długość diamentu w milimetrach, mierzona poziomo od jednego końca do drugiego. 
 
- **y dimension**:  
  Szerokość diamentu, mierzona w milimetrach, od strony do strony. 
 
- **z dimension**:  
  Głębokość diamentu, mierzona w milimetrach, od góry do dołu. 
 
- **depth**:  
  Wysokość diamentu jako procent stosunku głębokości do średnicy lub po prostu w milimetrach, wpływa na błysk diamentu. 
 
- **table**:  
  Płaska górna powierzchnia diamentu. Jej rozmiar ma wpływ na jakość szlifu. 
 
- **price**:  
  Cena diamentu, ustalana na podstawie wszystkich jego cech, w tym karatów, szlifu, czystości i koloru. 
 
 
#### Typ danych i kolumny 
</span><span class="s0">#%% 
</span><span class="s1">df</span><span class="s3">.</span><span class="s1">info</span><span class="s3">()</span>
<span class="s0">#%% md 
</span><span class="s1">Jak widać Python potraktował typy kolumn jako obiektowe, pomimo że są to dane numeryczne. Należy to obsłużyć 
 
#### Rozkład danych numerycznych i konwersja typów danych 
Kolumny posiadają znaki białe przed ich nazwami. Należy to oczyścić. Następnie należy zbadać typy danych i je skorygować. Tak aby można było w następnej fazie na nich pracować 
</span><span class="s0">#%% 
</span><span class="s1">print</span><span class="s3">(</span><span class="s1">df</span><span class="s3">.</span><span class="s1">columns</span><span class="s3">)</span>
<span class="s1">df </span><span class="s3">= </span><span class="s1">df</span><span class="s3">.</span><span class="s1">rename</span><span class="s3">(</span><span class="s1">columns</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">x</span><span class="s3">.</span><span class="s1">strip</span><span class="s3">())  </span><span class="s0"># Usuwa białe znaki z początku i końca nazw</span>

<span class="s1">df</span><span class="s3">[</span><span class="s4">'x dimension'</span><span class="s3">] = </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">to_numeric</span><span class="s3">(</span><span class="s1">df</span><span class="s3">[</span><span class="s4">'x dimension'</span><span class="s3">], </span><span class="s1">errors</span><span class="s3">=</span><span class="s4">'coerce'</span><span class="s3">)</span>
<span class="s1">df</span><span class="s3">[</span><span class="s4">'y dimension'</span><span class="s3">] = </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">to_numeric</span><span class="s3">(</span><span class="s1">df</span><span class="s3">[</span><span class="s4">'y dimension'</span><span class="s3">], </span><span class="s1">errors</span><span class="s3">=</span><span class="s4">'coerce'</span><span class="s3">)</span>
<span class="s1">df</span><span class="s3">[</span><span class="s4">'z dimension'</span><span class="s3">] = </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">to_numeric</span><span class="s3">(</span><span class="s1">df</span><span class="s3">[</span><span class="s4">'z dimension'</span><span class="s3">], </span><span class="s1">errors</span><span class="s3">=</span><span class="s4">'coerce'</span><span class="s3">)</span>
<span class="s1">df</span><span class="s3">[</span><span class="s4">'depth'</span><span class="s3">] = </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">to_numeric</span><span class="s3">(</span><span class="s1">df</span><span class="s3">[</span><span class="s4">'depth'</span><span class="s3">], </span><span class="s1">errors</span><span class="s3">=</span><span class="s4">'coerce'</span><span class="s3">)</span>
<span class="s1">df</span><span class="s3">[</span><span class="s4">'table'</span><span class="s3">] = </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">to_numeric</span><span class="s3">(</span><span class="s1">df</span><span class="s3">[</span><span class="s4">'table'</span><span class="s3">], </span><span class="s1">errors</span><span class="s3">=</span><span class="s4">'coerce'</span><span class="s3">)</span>
<span class="s1">df</span><span class="s3">[</span><span class="s4">'price'</span><span class="s3">] = </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">to_numeric</span><span class="s3">(</span><span class="s1">df</span><span class="s3">[</span><span class="s4">'price'</span><span class="s3">], </span><span class="s1">errors</span><span class="s3">=</span><span class="s4">'coerce'</span><span class="s3">)</span>

<span class="s1">df</span><span class="s3">.</span><span class="s1">describe</span><span class="s3">()</span>
<span class="s0">#%% md 
</span><span class="s1">powyżej znajdują się dane statystyczne na kolumnach (przed ich oczyszczeniem oraz uzupełnieniem/skasowaniem braków) 
 
#### Brakujące wartości 
</span><span class="s0">#%% 
</span><span class="s1">missing </span><span class="s3">= </span><span class="s1">df</span><span class="s3">.</span><span class="s1">isnull</span><span class="s3">().</span><span class="s1">sum</span><span class="s3">()</span>
<span class="s1">print</span><span class="s3">(</span><span class="s4">'Brakujące wartości: </span><span class="s2">\n</span><span class="s4">'</span><span class="s3">)</span>
<span class="s1">print</span><span class="s3">(</span><span class="s1">missing</span><span class="s3">)</span>
<span class="s1">print</span><span class="s3">(</span><span class="s4">'</span><span class="s2">\n</span><span class="s4">Procent brakujących wartości w każdej kolumnie: '</span><span class="s3">)</span>
<span class="s1">total </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">df</span><span class="s3">)</span>
<span class="s1">missing_percent </span><span class="s3">= (</span><span class="s1">df</span><span class="s3">.</span><span class="s1">isnull</span><span class="s3">().</span><span class="s1">sum</span><span class="s3">() / </span><span class="s1">total</span><span class="s3">) * </span><span class="s5">100</span>
<span class="s1">print</span><span class="s3">(</span><span class="s1">missing_percent</span><span class="s3">)</span>
<span class="s1">total_missings </span><span class="s3">= </span><span class="s1">df</span><span class="s3">.</span><span class="s1">isnull</span><span class="s3">().</span><span class="s1">sum</span><span class="s3">().</span><span class="s1">sum</span><span class="s3">()</span>
<span class="s1">total_missing_percentage </span><span class="s3">= (</span><span class="s1">total_missings </span><span class="s3">/ (</span><span class="s1">total </span><span class="s3">* </span><span class="s1">df</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])) * </span><span class="s5">100</span>
<span class="s1">print</span><span class="s3">(</span><span class="s4">f'</span><span class="s2">\n</span><span class="s4">Procent całkowitej liczby pustych wartości: </span><span class="s2">{</span><span class="s1">round</span><span class="s3">(</span><span class="s1">total_missing_percentage</span><span class="s3">,</span><span class="s5">2</span><span class="s3">)</span><span class="s2">}</span><span class="s4">%'</span><span class="s3">)</span>

<span class="s0">#%% md 
</span><span class="s1">Nasz zbiór danych jest mały, dlatego 13.45% uznaję jako wysoki procent braków w kolumnach 
 
# Strategia uzupełniania brakujących danych 
 
1. **Karata (50 brakujących)**: Rregresja do oszacowania na podstawie innych wymiarów. 
 
2. **Wymiary X, Y, Z (3, 64, 48 brakujących)**: Estymacja na podstawie dostępnych danych. 
 
3. **Głębokość (67 brakujących)**: Średnia/mediana lub obliczenia, jeśli wymiary X, Y, Z są dostępne. 
 
4. **Tabela (33 brakujące)**: Średnią/mediana. 
 
5. **Cena (4 brakujące)**: Usunąć lub szacunek regresją. 
 
Dane zostną uzupełnione w następnych krokach po zbadaniu ich dokładniej 
 
 
</span><span class="s0">#%% md 
</span><span class="s1">### Znalezienie duplikatów 
</span><span class="s0">#%% 
</span><span class="s1">duplicate_rows </span><span class="s3">= </span><span class="s1">df</span><span class="s3">[</span><span class="s1">df</span><span class="s3">.</span><span class="s1">duplicated</span><span class="s3">(</span><span class="s1">keep</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)]</span>
<span class="s1">number_of_duplicates </span><span class="s3">= </span><span class="s1">duplicate_rows</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

<span class="s1">print</span><span class="s3">(</span><span class="s4">f'Liczba duplikatów w danych: </span><span class="s2">{</span><span class="s1">number_of_duplicates</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>
<span class="s0">#%% md 
</span><span class="s1">W naszym zbiorze nie występują duplikaty. Nie musimy czyścić z nich danych 
 
#### Analiza wartości odstających 
 
Wykorzystamy wykresy pudełkowe do zidentyfikowania potencjalnych wartości odstających w naszych danych. 
 
 
</span><span class="s0">#%% 
</span>
<span class="s1">features </span><span class="s3">= [</span><span class="s4">'carat'</span><span class="s3">, </span><span class="s4">'x dimension'</span><span class="s3">, </span><span class="s4">'y dimension'</span><span class="s3">, </span><span class="s4">'z dimension'</span><span class="s3">, </span><span class="s4">'depth'</span><span class="s3">, </span><span class="s4">'table'</span><span class="s3">, </span><span class="s4">'price'</span><span class="s3">]</span>
<span class="s2">for </span><span class="s1">feature </span><span class="s2">in </span><span class="s1">features</span><span class="s3">:</span>
    <span class="s1">plt</span><span class="s3">.</span><span class="s1">figure</span><span class="s3">(</span><span class="s1">figsize</span><span class="s3">=(</span><span class="s5">10</span><span class="s3">, </span><span class="s5">6</span><span class="s3">))</span>
    <span class="s1">sns</span><span class="s3">.</span><span class="s1">boxplot</span><span class="s3">(</span><span class="s1">x</span><span class="s3">=</span><span class="s1">df</span><span class="s3">[</span><span class="s1">feature</span><span class="s3">])</span>
    <span class="s1">plt</span><span class="s3">.</span><span class="s1">title</span><span class="s3">(</span><span class="s1">feature</span><span class="s3">)</span>
    <span class="s1">plt</span><span class="s3">.</span><span class="s1">show</span><span class="s3">()</span>
<span class="s0">#%% md 
</span><span class="s1">###### Z wykresów wynika że zmienna price i zmienna depth mają wartości odstające. Należy je zbadać 
#### Wartości odstające 
##### Poza wąsy wykresów pudełkowych 
</span><span class="s0">#%% 
</span><span class="s2">for </span><span class="s1">column </span><span class="s2">in </span><span class="s1">df</span><span class="s3">.</span><span class="s1">select_dtypes</span><span class="s3">(</span><span class="s1">include</span><span class="s3">=[</span><span class="s4">'float64'</span><span class="s3">, </span><span class="s4">'int64'</span><span class="s3">]).</span><span class="s1">columns</span><span class="s3">:</span>
    <span class="s1">Q1 </span><span class="s3">= </span><span class="s1">df</span><span class="s3">[</span><span class="s1">column</span><span class="s3">].</span><span class="s1">quantile</span><span class="s3">(</span><span class="s5">0.25</span><span class="s3">)</span>
    <span class="s1">Q3 </span><span class="s3">= </span><span class="s1">df</span><span class="s3">[</span><span class="s1">column</span><span class="s3">].</span><span class="s1">quantile</span><span class="s3">(</span><span class="s5">0.75</span><span class="s3">)</span>
    <span class="s1">IQR </span><span class="s3">= </span><span class="s1">Q3 </span><span class="s3">- </span><span class="s1">Q1</span>
    <span class="s1">lower_bound </span><span class="s3">= </span><span class="s1">Q1 </span><span class="s3">- </span><span class="s5">1.5 </span><span class="s3">* </span><span class="s1">IQR</span>
    <span class="s1">upper_bound </span><span class="s3">= </span><span class="s1">Q3 </span><span class="s3">+ </span><span class="s5">1.5 </span><span class="s3">* </span><span class="s1">IQR</span>

    <span class="s1">outliers </span><span class="s3">= </span><span class="s1">df</span><span class="s3">[(</span><span class="s1">df</span><span class="s3">[</span><span class="s1">column</span><span class="s3">] &lt; </span><span class="s1">lower_bound</span><span class="s3">) | (</span><span class="s1">df</span><span class="s3">[</span><span class="s1">column</span><span class="s3">] &gt; </span><span class="s1">upper_bound</span><span class="s3">)]</span>

    <span class="s2">if not </span><span class="s1">outliers</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">:</span>
        <span class="s1">print</span><span class="s3">(</span><span class="s4">f&quot;Wartości odstające dla kolumny </span><span class="s2">{</span><span class="s1">column</span><span class="s2">}</span><span class="s4">:&quot;</span><span class="s3">)</span>
        <span class="s1">print</span><span class="s3">(</span><span class="s1">outliers</span><span class="s3">, </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s3">)</span>
<span class="s0">#%% md 
</span><span class="s1">#### Macierz korelacji między zmiennymi 
 
Przed uzupełnieniem braków 
 
</span><span class="s0">#%% 
</span><span class="s1">df_numeric </span><span class="s3">= </span><span class="s1">df</span><span class="s3">.</span><span class="s1">select_dtypes</span><span class="s3">(</span><span class="s1">include</span><span class="s3">=[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">number</span><span class="s3">])</span>
<span class="s1">correlation_matrix_before </span><span class="s3">= </span><span class="s1">df_numeric</span><span class="s3">.</span><span class="s1">corr</span><span class="s3">()</span>

<span class="s1">plt</span><span class="s3">.</span><span class="s1">figure</span><span class="s3">(</span><span class="s1">figsize</span><span class="s3">=(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">2</span><span class="s3">))</span>
<span class="s1">sns</span><span class="s3">.</span><span class="s1">heatmap</span><span class="s3">(</span><span class="s1">correlation_matrix_before</span><span class="s3">, </span><span class="s1">annot</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">fmt</span><span class="s3">=</span><span class="s4">&quot;.2f&quot;</span><span class="s3">, </span><span class="s1">cmap</span><span class="s3">=</span><span class="s4">'coolwarm'</span><span class="s3">)</span>
<span class="s1">plt</span><span class="s3">.</span><span class="s1">title</span><span class="s3">(</span><span class="s4">&quot;Macierz korelacji&quot;</span><span class="s3">)</span>
<span class="s1">plt</span><span class="s3">.</span><span class="s1">show</span><span class="s3">()</span>

<span class="s0">#%% md 
</span><span class="s1">#### Uzupełnienie brakujących wartości dla x dimension (Regrersja liniowa) 
</span><span class="s0">#%% 
#Kopia danych przed wstawiniem brakujących danych</span>
<span class="s1">df_before_input </span><span class="s3">= </span><span class="s1">df</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

<span class="s0"># Wyznacznie zbioru bez wartości NAN/Null</span>
<span class="s1">train_data_x </span><span class="s3">= </span><span class="s1">df</span><span class="s3">.</span><span class="s1">dropna</span><span class="s3">(</span><span class="s1">subset</span><span class="s3">=[</span><span class="s4">'x dimension'</span><span class="s3">, </span><span class="s4">'y dimension'</span><span class="s3">, </span><span class="s4">'z dimension'</span><span class="s3">])</span>
<span class="s1">X_train_x </span><span class="s3">= </span><span class="s1">train_data_x</span><span class="s3">[[</span><span class="s4">'y dimension'</span><span class="s3">, </span><span class="s4">'z dimension'</span><span class="s3">]]</span>
<span class="s1">y_train_x </span><span class="s3">= </span><span class="s1">train_data_x</span><span class="s3">[</span><span class="s4">'x dimension'</span><span class="s3">]</span>
<span class="s0"># Regresja liniowa</span>
<span class="s1">model_x </span><span class="s3">= </span><span class="s1">LinearRegression</span><span class="s3">()</span>
<span class="s1">model_x</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train_x</span><span class="s3">, </span><span class="s1">y_train_x</span><span class="s3">)</span>

<span class="s0"># Wyznaczenie zboru gdzie 'x dimension' jest NAN ale 'y dimension' i 'z dimension' nie sa NAN</span>
<span class="s1">predict_data </span><span class="s3">= </span><span class="s1">df</span><span class="s3">[</span><span class="s1">df</span><span class="s3">[</span><span class="s4">'x dimension'</span><span class="s3">].</span><span class="s1">isna</span><span class="s3">() &amp; </span><span class="s1">df</span><span class="s3">[</span><span class="s4">'y dimension'</span><span class="s3">].</span><span class="s1">notna</span><span class="s3">() &amp; </span><span class="s1">df</span><span class="s3">[</span><span class="s4">'z dimension'</span><span class="s3">].</span><span class="s1">notna</span><span class="s3">()]</span>
<span class="s1">num_rows </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">predict_data</span><span class="s3">)</span>
<span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;Number of rows for prediction:&quot;</span><span class="s3">, </span><span class="s1">num_rows</span><span class="s3">)</span>
<span class="s1">X_predict </span><span class="s3">= </span><span class="s1">predict_data</span><span class="s3">[[</span><span class="s4">'y dimension'</span><span class="s3">, </span><span class="s4">'z dimension'</span><span class="s3">]]</span>

<span class="s1">predict_data_indices </span><span class="s3">= </span><span class="s1">predict_data</span><span class="s3">.</span><span class="s1">index</span>

<span class="s1">predicted_x </span><span class="s3">= </span><span class="s1">model_x</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X_predict</span><span class="s3">)</span>

<span class="s0"># Aktualizacja oryginalnego df'u</span>
<span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">index </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">predict_data_indices</span><span class="s3">):</span>
    <span class="s1">df</span><span class="s3">.</span><span class="s1">at</span><span class="s3">[</span><span class="s1">index</span><span class="s3">, </span><span class="s4">'x dimension'</span><span class="s3">] = </span><span class="s1">predicted_x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
    <span class="s1">print</span><span class="s3">(</span><span class="s4">f&quot;Predykcja dla indeksu </span><span class="s2">{</span><span class="s1">index</span><span class="s2">}</span><span class="s4">: </span><span class="s2">{</span><span class="s1">predicted_x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>
<span class="s0">#%% md 
</span><span class="s1">#### Uzupełnienie brakujących wartości dla y dimension (regresja liniowa) 
</span><span class="s0">#%% 
# Wyznacznie zbioru bez wartości NAN/Null</span>
<span class="s1">train_data_y </span><span class="s3">= </span><span class="s1">df</span><span class="s3">.</span><span class="s1">dropna</span><span class="s3">(</span><span class="s1">subset</span><span class="s3">=[</span><span class="s4">'y dimension'</span><span class="s3">,</span><span class="s4">'x dimension'</span><span class="s3">, </span><span class="s4">'z dimension'</span><span class="s3">])</span>
<span class="s1">X_train_y </span><span class="s3">= </span><span class="s1">train_data_y</span><span class="s3">[[</span><span class="s4">'x dimension'</span><span class="s3">, </span><span class="s4">'z dimension'</span><span class="s3">]]</span>
<span class="s1">y_train_y </span><span class="s3">= </span><span class="s1">train_data_y</span><span class="s3">[</span><span class="s4">'y dimension'</span><span class="s3">]</span>
<span class="s0"># Regresja liniowa</span>
<span class="s1">model_y </span><span class="s3">= </span><span class="s1">LinearRegression</span><span class="s3">()</span>
<span class="s1">model_y</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train_y</span><span class="s3">, </span><span class="s1">y_train_y</span><span class="s3">)</span>

<span class="s0"># Wyznaczenie zboru gdzie 'x dimension' jest NAN ale 'y dimension' i 'z dimension' nie sa NAN</span>
<span class="s1">predict_data_y </span><span class="s3">= </span><span class="s1">df</span><span class="s3">[</span><span class="s1">df</span><span class="s3">[</span><span class="s4">'y dimension'</span><span class="s3">].</span><span class="s1">isna</span><span class="s3">() &amp; </span><span class="s1">df</span><span class="s3">[</span><span class="s4">'x dimension'</span><span class="s3">].</span><span class="s1">notna</span><span class="s3">() &amp; </span><span class="s1">df</span><span class="s3">[</span><span class="s4">'z dimension'</span><span class="s3">].</span><span class="s1">notna</span><span class="s3">()]</span>
<span class="s1">num_rows </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">predict_data_y</span><span class="s3">)</span>
<span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;Number of rows for prediction:&quot;</span><span class="s3">, </span><span class="s1">num_rows</span><span class="s3">)</span>
<span class="s1">Y_predict </span><span class="s3">= </span><span class="s1">predict_data_y</span><span class="s3">[[</span><span class="s4">'x dimension'</span><span class="s3">, </span><span class="s4">'z dimension'</span><span class="s3">]]</span>

<span class="s1">predict_data_indices_y </span><span class="s3">= </span><span class="s1">predict_data_y</span><span class="s3">.</span><span class="s1">index</span>

<span class="s1">predicted_y </span><span class="s3">= </span><span class="s1">model_y</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">Y_predict</span><span class="s3">)</span>

<span class="s0"># Aktualizacja oryginalnego df'u</span>
<span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">index </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">predict_data_indices_y</span><span class="s3">):</span>
    <span class="s1">df</span><span class="s3">.</span><span class="s1">at</span><span class="s3">[</span><span class="s1">index</span><span class="s3">, </span><span class="s4">'y dimension'</span><span class="s3">] = </span><span class="s1">predicted_y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
    <span class="s1">print</span><span class="s3">(</span><span class="s4">f&quot;Predykcja dla indeksu </span><span class="s2">{</span><span class="s1">index</span><span class="s2">}</span><span class="s4">: </span><span class="s2">{</span><span class="s1">predicted_y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>
<span class="s0">#%% md 
</span><span class="s1">#### Uzupełnienie brakujących wartości dla z dimension (regresja liniowa) 
</span><span class="s0">#%% 
# Wyznacznie zbioru bez wartości NAN/Null</span>
<span class="s1">train_data_z </span><span class="s3">= </span><span class="s1">df</span><span class="s3">.</span><span class="s1">dropna</span><span class="s3">(</span><span class="s1">subset</span><span class="s3">=[</span><span class="s4">'z dimension'</span><span class="s3">,</span><span class="s4">'y dimension'</span><span class="s3">,</span><span class="s4">'x dimension'</span><span class="s3">])</span>
<span class="s1">X_train_z </span><span class="s3">= </span><span class="s1">train_data_z</span><span class="s3">[[</span><span class="s4">'y dimension'</span><span class="s3">, </span><span class="s4">'x dimension'</span><span class="s3">]]</span>
<span class="s1">y_train_z </span><span class="s3">= </span><span class="s1">train_data_z</span><span class="s3">[</span><span class="s4">'z dimension'</span><span class="s3">]</span>
<span class="s0"># Regresja liniowa</span>
<span class="s1">model_z </span><span class="s3">= </span><span class="s1">LinearRegression</span><span class="s3">()</span>
<span class="s1">model_z</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train_z</span><span class="s3">, </span><span class="s1">y_train_z</span><span class="s3">)</span>

<span class="s0"># Wyznaczenie zboru gdzie 'x dimension' jest NAN ale 'y dimension' i 'z dimension' nie sa NAN</span>
<span class="s1">predict_data_z </span><span class="s3">= </span><span class="s1">df</span><span class="s3">[</span><span class="s1">df</span><span class="s3">[</span><span class="s4">'z dimension'</span><span class="s3">].</span><span class="s1">isna</span><span class="s3">() &amp; </span><span class="s1">df</span><span class="s3">[</span><span class="s4">'y dimension'</span><span class="s3">].</span><span class="s1">notna</span><span class="s3">() &amp; </span><span class="s1">df</span><span class="s3">[</span><span class="s4">'x dimension'</span><span class="s3">].</span><span class="s1">notna</span><span class="s3">()]</span>
<span class="s1">num_rows </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">predict_data_z</span><span class="s3">)</span>
<span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;Number of rows for prediction:&quot;</span><span class="s3">, </span><span class="s1">num_rows</span><span class="s3">)</span>
<span class="s1">Z_predict </span><span class="s3">= </span><span class="s1">predict_data_z</span><span class="s3">[[</span><span class="s4">'y dimension'</span><span class="s3">, </span><span class="s4">'x dimension'</span><span class="s3">]]</span>

<span class="s1">predict_data_indices_z </span><span class="s3">= </span><span class="s1">predict_data_z</span><span class="s3">.</span><span class="s1">index</span>

<span class="s1">predicted_z </span><span class="s3">= </span><span class="s1">model_z</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">Z_predict</span><span class="s3">)</span>

<span class="s0"># Aktualizacja oryginalnego df'u</span>
<span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">index </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">predict_data_indices_z</span><span class="s3">):</span>
    <span class="s1">df</span><span class="s3">.</span><span class="s1">at</span><span class="s3">[</span><span class="s1">index</span><span class="s3">, </span><span class="s4">'z dimension'</span><span class="s3">] = </span><span class="s1">predicted_z</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
    <span class="s1">print</span><span class="s3">(</span><span class="s4">f&quot;Predykcja dla indeksu </span><span class="s2">{</span><span class="s1">index</span><span class="s2">}</span><span class="s4">: </span><span class="s2">{</span><span class="s1">predicted_z</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>
<span class="s0">#%% md 
</span><span class="s1">#### Uzupełnienie brakujących wartości dla carat (regresja liniowa) 
 
</span><span class="s0">#%% 
# Wyznacznie zbioru bez wartości NAN/Null</span>
<span class="s1">train_data_carat </span><span class="s3">= </span><span class="s1">df</span><span class="s3">.</span><span class="s1">dropna</span><span class="s3">(</span><span class="s1">subset</span><span class="s3">=[</span><span class="s4">'carat'</span><span class="s3">,</span><span class="s4">'z dimension'</span><span class="s3">,</span><span class="s4">'y dimension'</span><span class="s3">,</span><span class="s4">'x dimension'</span><span class="s3">])</span>
<span class="s1">X_train_carat </span><span class="s3">= </span><span class="s1">train_data_carat</span><span class="s3">[[</span><span class="s4">'y dimension'</span><span class="s3">, </span><span class="s4">'x dimension'</span><span class="s3">, </span><span class="s4">'z dimension'</span><span class="s3">]]</span>
<span class="s1">y_train_carat </span><span class="s3">= </span><span class="s1">train_data_carat</span><span class="s3">[</span><span class="s4">'carat'</span><span class="s3">]</span>
<span class="s0"># Regresja liniowa</span>
<span class="s1">model_carat </span><span class="s3">= </span><span class="s1">LinearRegression</span><span class="s3">()</span>
<span class="s1">model_carat</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train_carat</span><span class="s3">, </span><span class="s1">y_train_carat</span><span class="s3">)</span>

<span class="s1">predict_data_carat </span><span class="s3">= </span><span class="s1">df</span><span class="s3">[</span><span class="s1">df</span><span class="s3">[</span><span class="s4">'carat'</span><span class="s3">].</span><span class="s1">isna</span><span class="s3">() &amp; </span><span class="s1">df</span><span class="s3">[</span><span class="s4">'y dimension'</span><span class="s3">].</span><span class="s1">notna</span><span class="s3">() &amp; </span><span class="s1">df</span><span class="s3">[</span><span class="s4">'x dimension'</span><span class="s3">].</span><span class="s1">notna</span><span class="s3">()&amp; </span><span class="s1">df</span><span class="s3">[</span><span class="s4">'z dimension'</span><span class="s3">].</span><span class="s1">notna</span><span class="s3">()]</span>
<span class="s1">num_rows </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">predict_data_carat</span><span class="s3">)</span>
<span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;Number of rows for prediction:&quot;</span><span class="s3">, </span><span class="s1">num_rows</span><span class="s3">)</span>
<span class="s1">carat_predict </span><span class="s3">= </span><span class="s1">predict_data_carat</span><span class="s3">[[</span><span class="s4">'y dimension'</span><span class="s3">, </span><span class="s4">'x dimension'</span><span class="s3">, </span><span class="s4">'z dimension'</span><span class="s3">]]</span>

<span class="s1">predict_data_indices_carat </span><span class="s3">= </span><span class="s1">predict_data_carat</span><span class="s3">.</span><span class="s1">index</span>

<span class="s1">predicted_carat </span><span class="s3">= </span><span class="s1">model_carat</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">carat_predict</span><span class="s3">)</span>

<span class="s0"># Aktualizacja oryginalnego df'u</span>
<span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">index </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">predict_data_indices_carat</span><span class="s3">):</span>
    <span class="s1">df</span><span class="s3">.</span><span class="s1">at</span><span class="s3">[</span><span class="s1">index</span><span class="s3">, </span><span class="s4">'carat'</span><span class="s3">] = </span><span class="s1">predicted_carat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
    <span class="s1">print</span><span class="s3">(</span><span class="s4">f&quot;Predykcja dla indeksu </span><span class="s2">{</span><span class="s1">index</span><span class="s2">}</span><span class="s4">: </span><span class="s2">{</span><span class="s1">predicted_carat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>
<span class="s0">#%% md 
</span><span class="s1">#### Uzupełnienie depth i table (KNN)  
</span><span class="s0">#%% 
</span><span class="s1">df_original </span><span class="s3">= </span><span class="s1">df</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

<span class="s0"># Inicjalizacja imputera KNN</span>
<span class="s1">imputer </span><span class="s3">= </span><span class="s1">KNNImputer</span><span class="s3">(</span><span class="s1">n_neighbors</span><span class="s3">=</span><span class="s5">5</span><span class="s3">)</span>
<span class="s1">df</span><span class="s3">[[</span><span class="s4">'depth'</span><span class="s3">, </span><span class="s4">'table'</span><span class="s3">]] = </span><span class="s1">imputer</span><span class="s3">.</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">df</span><span class="s3">[[</span><span class="s4">'depth'</span><span class="s3">, </span><span class="s4">'table'</span><span class="s3">]])</span>

<span class="s0"># Wyświetlenie imputowanych wartości z opisem</span>
<span class="s2">for </span><span class="s1">column </span><span class="s2">in </span><span class="s3">[</span><span class="s4">'depth'</span><span class="s3">, </span><span class="s4">'table'</span><span class="s3">]:</span>
    <span class="s1">imputed_values </span><span class="s3">= </span><span class="s1">df</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">[</span><span class="s1">df_original</span><span class="s3">[</span><span class="s1">column</span><span class="s3">].</span><span class="s1">isnull</span><span class="s3">(), </span><span class="s1">column</span><span class="s3">]</span>
    <span class="s1">print</span><span class="s3">(</span><span class="s4">f&quot;Imputed values for </span><span class="s2">{</span><span class="s1">column</span><span class="s2">}</span><span class="s4">:&quot;</span><span class="s3">)</span>
    <span class="s1">print</span><span class="s3">(</span><span class="s1">imputed_values</span><span class="s3">)</span>
<span class="s0">#%% md 
</span><span class="s1">### Porównanie danych przed i po wstawieniu przewidzianych wartości 
 Analiza statystyk opisowych 
</span><span class="s0">#%% 
</span><span class="s1">print</span><span class="s3">(</span><span class="s4">'przed'</span><span class="s3">)</span>
<span class="s1">df_before_input</span><span class="s3">.</span><span class="s1">describe</span><span class="s3">()</span>
<span class="s0">#%% 
</span><span class="s1">print</span><span class="s3">(</span><span class="s4">'po'</span><span class="s3">)</span>
<span class="s1">df</span><span class="s3">.</span><span class="s1">describe</span><span class="s3">()</span>
<span class="s0">#%% md 
</span><span class="s1">##### Analizując dane statystyczne widzimy, że nie zostały one zachwiane. Zatem możemy załozyć, że imputacja zakończyłą się sukcesem 
</span><span class="s0">#%% md 
</span><span class="s1">##### Analiza jakości modelowania 
Porównam jakość modelu, który uzyskałem po uzupełnieniu brakujących wartości przy pomocy regresji liniowej (LR) i metody najbliższych sąsiadów (KNN), z modelem, w którym puste wartości uzupełniono średnimi. 
</span><span class="s0">#%% 
</span>
<span class="s0"># Wybór modelu - na przykład RandomForestRegressor</span>
<span class="s1">model </span><span class="s3">= </span><span class="s1">RandomForestRegressor</span><span class="s3">()</span>

<span class="s1">imputer </span><span class="s3">= </span><span class="s1">SimpleImputer</span><span class="s3">(</span><span class="s1">strategy</span><span class="s3">=</span><span class="s4">'mean'</span><span class="s3">)  </span><span class="s0"># Możesz wybrać inną strategię, np. 'median' lub 'most_frequent'</span>
<span class="s1">df_numeric </span><span class="s3">= </span><span class="s1">df_before_input</span><span class="s3">.</span><span class="s1">select_dtypes</span><span class="s3">(</span><span class="s1">include</span><span class="s3">=[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">number</span><span class="s3">])</span>
<span class="s1">df_imputed </span><span class="s3">= </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">DataFrame</span><span class="s3">(</span><span class="s1">imputer</span><span class="s3">.</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">df_numeric</span><span class="s3">), </span><span class="s1">columns</span><span class="s3">=</span><span class="s1">df_numeric</span><span class="s3">.</span><span class="s1">columns</span><span class="s3">)</span>

<span class="s0"># Podział danych na treningowe i testowe</span>
<span class="s1">X_train</span><span class="s3">, </span><span class="s1">X_test</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">, </span><span class="s1">y_test </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span><span class="s1">df_imputed</span><span class="s3">[[</span><span class="s4">'carat'</span><span class="s3">, </span><span class="s4">'x dimension'</span><span class="s3">, </span><span class="s4">'y dimension'</span><span class="s3">, </span><span class="s4">'z dimension'</span><span class="s3">, </span><span class="s4">'depth'</span><span class="s3">, </span><span class="s4">'table'</span><span class="s3">]], </span><span class="s1">df_imputed</span><span class="s3">[</span><span class="s4">'price'</span><span class="s3">], </span><span class="s1">test_size</span><span class="s3">=</span><span class="s5">0.3</span><span class="s3">)</span>

<span class="s0"># Trenowanie modelu na danych przed imputacją</span>
<span class="s1">model</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">)</span>
<span class="s1">predictions </span><span class="s3">= </span><span class="s1">model</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">)</span>
<span class="s1">mse_before </span><span class="s3">= </span><span class="s1">mean_squared_error</span><span class="s3">(</span><span class="s1">y_test</span><span class="s3">, </span><span class="s1">predictions</span><span class="s3">)</span>


<span class="s0"># Trenowanie modelu na danych po imputacji</span>
<span class="s1">X_train_imputed</span><span class="s3">, </span><span class="s1">X_test_imputed</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span><span class="s1">df</span><span class="s3">[[</span><span class="s4">'carat'</span><span class="s3">, </span><span class="s4">'x dimension'</span><span class="s3">, </span><span class="s4">'y dimension'</span><span class="s3">, </span><span class="s4">'z dimension'</span><span class="s3">, </span><span class="s4">'depth'</span><span class="s3">, </span><span class="s4">'table'</span><span class="s3">]], </span><span class="s1">df</span><span class="s3">[</span><span class="s4">'price'</span><span class="s3">], </span><span class="s1">test_size</span><span class="s3">=</span><span class="s5">0.3</span><span class="s3">)</span>
<span class="s1">model</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train_imputed</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">)</span>
<span class="s1">predictions_imputed </span><span class="s3">= </span><span class="s1">model</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X_test_imputed</span><span class="s3">)</span>
<span class="s1">mse_after </span><span class="s3">= </span><span class="s1">mean_squared_error</span><span class="s3">(</span><span class="s1">y_test</span><span class="s3">, </span><span class="s1">predictions_imputed</span><span class="s3">)</span>


<span class="s0"># Obliczanie metryk przed imputacją</span>
<span class="s1">rmse_before</span><span class="s3">, </span><span class="s1">mae_before</span><span class="s3">, </span><span class="s1">r2_before</span><span class="s3">, </span><span class="s1">adjusted_r2_before </span><span class="s3">= </span><span class="s1">calculate_metrics</span><span class="s3">(</span><span class="s1">y_test</span><span class="s3">, </span><span class="s1">predictions</span><span class="s3">, </span><span class="s1">X_test</span><span class="s3">)</span>

<span class="s0"># Obliczanie metryk po imputacji</span>
<span class="s1">rmse_after</span><span class="s3">, </span><span class="s1">mae_after</span><span class="s3">, </span><span class="s1">r2_after</span><span class="s3">, </span><span class="s1">adjusted_r2_after </span><span class="s3">= </span><span class="s1">calculate_metrics</span><span class="s3">(</span><span class="s1">y_test</span><span class="s3">, </span><span class="s1">predictions_imputed</span><span class="s3">, </span><span class="s1">X_test_imputed</span><span class="s3">)</span>

<span class="s0"># Wyświetlanie wyników</span>
<span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;Średnia:&quot;</span><span class="s3">)</span>
<span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;MSE Średnia:&quot;</span><span class="s3">, </span><span class="s1">mse_before</span><span class="s3">)</span>
<span class="s1">print</span><span class="s3">(</span><span class="s4">f&quot;RMSE: </span><span class="s2">{</span><span class="s1">rmse_before</span><span class="s2">}</span><span class="s4">, MAE: </span><span class="s2">{</span><span class="s1">mae_before</span><span class="s2">}</span><span class="s4">, R^2: </span><span class="s2">{</span><span class="s1">r2_before</span><span class="s2">}</span><span class="s4">, Adjusted R^2: </span><span class="s2">{</span><span class="s1">adjusted_r2_before</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>

<span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">Po LR i KNN:&quot;</span><span class="s3">)</span>
<span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;MSE LR i KNN:&quot;</span><span class="s3">, </span><span class="s1">mse_after</span><span class="s3">)</span>
<span class="s1">print</span><span class="s3">(</span><span class="s4">f&quot;RMSE: </span><span class="s2">{</span><span class="s1">rmse_after</span><span class="s2">}</span><span class="s4">, MAE: </span><span class="s2">{</span><span class="s1">mae_after</span><span class="s2">}</span><span class="s4">, R^2: </span><span class="s2">{</span><span class="s1">r2_after</span><span class="s2">}</span><span class="s4">, Adjusted R^2: </span><span class="s2">{</span><span class="s1">adjusted_r2_after</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>



<span class="s0">#%% md 
</span><span class="s1">#### Metryki 
Wynik Błędu średniokwadratowego po imputacji przy użyciu LR i KNN jest niższy, co wskazuje na lepsze dopasowanie modelu do danych. 
 
Wyniki reszty metryk również wskazują na poprawę jakości przy LR i KNN 
 
 
</span><span class="s0">#%% md 
</span>
<span class="s0">#%% md 
</span><span class="s1">Wysoka korelacja między cechami związanych z rozmiarem: Widać, że cechy carat, x dimension, y dimension oraz z dimension mają bardzo wysokie współczynniki korelacji, zbliżone do 1. Oznacza to, że są one silnie ze sobą powiązane. W praktyce, rozmiar kamienia jest zazwyczaj proporcjonalny do jego wymiarów. 
 
Średnia korelacja między depth a dimensions oraz carat 
 
#### Z-score 
##### Obserwacje o wartościach Z-Score większych niż 3 lub mniejszych niż -3 można uznać za wartości odstające 
</span><span class="s0">#%% 
# Upewnij się, że dane są w odpowiednim formacie</span>
<span class="s1">df</span><span class="s3">[</span><span class="s4">'carat'</span><span class="s3">] = </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">to_numeric</span><span class="s3">(</span><span class="s1">df</span><span class="s3">[</span><span class="s4">'carat'</span><span class="s3">], </span><span class="s1">errors</span><span class="s3">=</span><span class="s4">'coerce'</span><span class="s3">)</span>

<span class="s0"># Oblicz z-score dla całej kolumny 'carat' z pominięciem wartości NaN</span>
<span class="s1">df</span><span class="s3">[</span><span class="s4">'carat_zscore'</span><span class="s3">] = </span><span class="s1">zscore</span><span class="s3">(</span><span class="s1">df</span><span class="s3">[</span><span class="s4">'carat'</span><span class="s3">].</span><span class="s1">dropna</span><span class="s3">())</span>

<span class="s0"># Wartości NaN w 'carat' będą miały odpowiednik NaN w 'carat_zscore'</span>
<span class="s0"># Tworzymy nową serię, która będzie miała tyle samo elementów co df['carat']</span>
<span class="s0"># a następnie przypiszemy jej wartości obliczonego z-score zgodnie z oryginalnym indeksem.</span>
<span class="s1">carat_zscores </span><span class="s3">= </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">Series</span><span class="s3">(</span><span class="s1">data</span><span class="s3">=</span><span class="s1">zscore</span><span class="s3">(</span><span class="s1">df</span><span class="s3">[</span><span class="s4">'carat'</span><span class="s3">].</span><span class="s1">dropna</span><span class="s3">()), </span><span class="s1">index</span><span class="s3">=</span><span class="s1">df</span><span class="s3">[</span><span class="s4">'carat'</span><span class="s3">].</span><span class="s1">dropna</span><span class="s3">().</span><span class="s1">index</span><span class="s3">)</span>

<span class="s0"># Teraz tworzymy nową kolumnę 'carat_zscore' która jest pusta</span>
<span class="s1">df</span><span class="s3">[</span><span class="s4">'carat_zscore'</span><span class="s3">] = </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">NaT</span>

<span class="s0"># Wstawiamy wartości zscore do nowej kolumny zgodnie z ich oryginalnym indeksem.</span>
<span class="s1">df</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">[</span><span class="s1">carat_zscores</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s4">'carat_zscore'</span><span class="s3">] = </span><span class="s1">carat_zscores</span>

<span class="s0"># Wyświetlenie DataFrame</span>
<span class="s1">print</span><span class="s3">(</span><span class="s1">df</span><span class="s3">[[</span><span class="s4">'carat'</span><span class="s3">, </span><span class="s4">'carat_zscore'</span><span class="s3">]])</span>
<span class="s0">#%% md 
</span>
<span class="s0">#%% 
# Wizualizacja rozkładu zmiennych ciągłych</span>
<span class="s1">continuous_columns </span><span class="s3">= [</span><span class="s4">'carat'</span><span class="s3">, </span><span class="s4">'x dimension'</span><span class="s3">, </span><span class="s4">'y dimension'</span><span class="s3">, </span><span class="s4">'z dimension'</span><span class="s3">, </span><span class="s4">'depth'</span><span class="s3">, </span><span class="s4">'table'</span><span class="s3">, </span><span class="s4">'price'</span><span class="s3">]</span>
<span class="s2">for </span><span class="s1">column </span><span class="s2">in </span><span class="s1">continuous_columns</span><span class="s3">:</span>
    <span class="s1">plt</span><span class="s3">.</span><span class="s1">figure</span><span class="s3">(</span><span class="s1">figsize</span><span class="s3">=(</span><span class="s5">10</span><span class="s3">, </span><span class="s5">6</span><span class="s3">))</span>
    <span class="s1">sns</span><span class="s3">.</span><span class="s1">histplot</span><span class="s3">(</span><span class="s1">df</span><span class="s3">[</span><span class="s1">column</span><span class="s3">], </span><span class="s1">kde</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">plt</span><span class="s3">.</span><span class="s1">title</span><span class="s3">(</span><span class="s4">f'Distribution of </span><span class="s2">{</span><span class="s1">column</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>
    <span class="s1">plt</span><span class="s3">.</span><span class="s1">xlabel</span><span class="s3">(</span><span class="s1">column</span><span class="s3">)</span>
    <span class="s1">plt</span><span class="s3">.</span><span class="s1">ylabel</span><span class="s3">(</span><span class="s4">'Frequency'</span><span class="s3">)</span>
    <span class="s1">plt</span><span class="s3">.</span><span class="s1">show</span><span class="s3">()</span>

<span class="s0"># Zależności ceny od innych zmiennych</span>
<span class="s2">for </span><span class="s1">column </span><span class="s2">in </span><span class="s1">continuous_columns</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">]:  </span><span class="s0"># ostatnia kolumna to cena, więc jest pomijana</span>
    <span class="s1">plt</span><span class="s3">.</span><span class="s1">figure</span><span class="s3">(</span><span class="s1">figsize</span><span class="s3">=(</span><span class="s5">10</span><span class="s3">, </span><span class="s5">6</span><span class="s3">))</span>
    <span class="s1">sns</span><span class="s3">.</span><span class="s1">scatterplot</span><span class="s3">(</span><span class="s1">x</span><span class="s3">=</span><span class="s1">df</span><span class="s3">[</span><span class="s1">column</span><span class="s3">], </span><span class="s1">y</span><span class="s3">=</span><span class="s1">df</span><span class="s3">[</span><span class="s4">'price'</span><span class="s3">])</span>
    <span class="s1">plt</span><span class="s3">.</span><span class="s1">title</span><span class="s3">(</span><span class="s4">f'Price dependency on </span><span class="s2">{</span><span class="s1">column</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>
    <span class="s1">plt</span><span class="s3">.</span><span class="s1">xlabel</span><span class="s3">(</span><span class="s1">column</span><span class="s3">)</span>
    <span class="s1">plt</span><span class="s3">.</span><span class="s1">ylabel</span><span class="s3">(</span><span class="s4">'Price'</span><span class="s3">)</span>
    <span class="s1">plt</span><span class="s3">.</span><span class="s1">show</span><span class="s3">()</span>

<span class="s0"># Liczebność kategorii dla każdej z kolumn kategorycznych</span>
<span class="s1">categorical_columns </span><span class="s3">= [</span><span class="s4">'clarity'</span><span class="s3">, </span><span class="s4">'color'</span><span class="s3">, </span><span class="s4">'cut'</span><span class="s3">]</span>
<span class="s2">for </span><span class="s1">column </span><span class="s2">in </span><span class="s1">categorical_columns</span><span class="s3">:</span>
    <span class="s1">plt</span><span class="s3">.</span><span class="s1">figure</span><span class="s3">(</span><span class="s1">figsize</span><span class="s3">=(</span><span class="s5">15</span><span class="s3">, </span><span class="s5">8</span><span class="s3">))</span>
    <span class="s1">sns</span><span class="s3">.</span><span class="s1">countplot</span><span class="s3">(</span><span class="s1">x</span><span class="s3">=</span><span class="s1">df</span><span class="s3">[</span><span class="s1">column</span><span class="s3">])</span>
    <span class="s1">plt</span><span class="s3">.</span><span class="s1">title</span><span class="s3">(</span><span class="s4">f'Count of categories in </span><span class="s2">{</span><span class="s1">column</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>
    <span class="s1">plt</span><span class="s3">.</span><span class="s1">xlabel</span><span class="s3">(</span><span class="s1">column</span><span class="s3">)</span>
    <span class="s1">plt</span><span class="s3">.</span><span class="s1">ylabel</span><span class="s3">(</span><span class="s4">'Count'</span><span class="s3">)</span>
    <span class="s1">plt</span><span class="s3">.</span><span class="s1">show</span><span class="s3">()</span></pre>
</body>
</html>